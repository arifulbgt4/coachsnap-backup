// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activity: (where?: ActivityWhereInput) => Promise<boolean>;
  availability: (where?: AvailabilityWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  businessHour: (where?: BusinessHourWhereInput) => Promise<boolean>;
  charge: (where?: ChargeWhereInput) => Promise<boolean>;
  content: (where?: ContentWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  lastLogin: (where?: LastLoginWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  sessionType: (where?: SessionTypeWhereInput) => Promise<boolean>;
  stripeAccount: (where?: StripeAccountWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activity: (where: ActivityWhereUniqueInput) => ActivityNullablePromise;
  activities: (args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Activity>;
  activitiesConnection: (args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActivityConnectionPromise;
  availability: (
    where: AvailabilityWhereUniqueInput
  ) => AvailabilityNullablePromise;
  availabilities: (args?: {
    where?: AvailabilityWhereInput;
    orderBy?: AvailabilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Availability>;
  availabilitiesConnection: (args?: {
    where?: AvailabilityWhereInput;
    orderBy?: AvailabilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvailabilityConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingNullablePromise;
  bookings: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Booking>;
  bookingsConnection: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookingConnectionPromise;
  businessHour: (
    where: BusinessHourWhereUniqueInput
  ) => BusinessHourNullablePromise;
  businessHours: (args?: {
    where?: BusinessHourWhereInput;
    orderBy?: BusinessHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BusinessHour>;
  businessHoursConnection: (args?: {
    where?: BusinessHourWhereInput;
    orderBy?: BusinessHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BusinessHourConnectionPromise;
  charge: (where: ChargeWhereUniqueInput) => ChargeNullablePromise;
  charges: (args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Charge>;
  chargesConnection: (args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChargeConnectionPromise;
  content: (where: ContentWhereUniqueInput) => ContentNullablePromise;
  contents: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Content>;
  contentsConnection: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  lastLogin: (where: LastLoginWhereUniqueInput) => LastLoginNullablePromise;
  lastLogins: (args?: {
    where?: LastLoginWhereInput;
    orderBy?: LastLoginOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LastLogin>;
  lastLoginsConnection: (args?: {
    where?: LastLoginWhereInput;
    orderBy?: LastLoginOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LastLoginConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  sessionType: (
    where: SessionTypeWhereUniqueInput
  ) => SessionTypeNullablePromise;
  sessionTypes: (args?: {
    where?: SessionTypeWhereInput;
    orderBy?: SessionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SessionType>;
  sessionTypesConnection: (args?: {
    where?: SessionTypeWhereInput;
    orderBy?: SessionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionTypeConnectionPromise;
  stripeAccount: (
    where: StripeAccountWhereUniqueInput
  ) => StripeAccountNullablePromise;
  stripeAccounts: (args?: {
    where?: StripeAccountWhereInput;
    orderBy?: StripeAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StripeAccount>;
  stripeAccountsConnection: (args?: {
    where?: StripeAccountWhereInput;
    orderBy?: StripeAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StripeAccountConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivity: (data: ActivityCreateInput) => ActivityPromise;
  updateActivity: (args: {
    data: ActivityUpdateInput;
    where: ActivityWhereUniqueInput;
  }) => ActivityPromise;
  upsertActivity: (args: {
    where: ActivityWhereUniqueInput;
    create: ActivityCreateInput;
    update: ActivityUpdateInput;
  }) => ActivityPromise;
  deleteActivity: (where: ActivityWhereUniqueInput) => ActivityPromise;
  deleteManyActivities: (where?: ActivityWhereInput) => BatchPayloadPromise;
  createAvailability: (data: AvailabilityCreateInput) => AvailabilityPromise;
  updateAvailability: (args: {
    data: AvailabilityUpdateInput;
    where: AvailabilityWhereUniqueInput;
  }) => AvailabilityPromise;
  updateManyAvailabilities: (args: {
    data: AvailabilityUpdateManyMutationInput;
    where?: AvailabilityWhereInput;
  }) => BatchPayloadPromise;
  upsertAvailability: (args: {
    where: AvailabilityWhereUniqueInput;
    create: AvailabilityCreateInput;
    update: AvailabilityUpdateInput;
  }) => AvailabilityPromise;
  deleteAvailability: (
    where: AvailabilityWhereUniqueInput
  ) => AvailabilityPromise;
  deleteManyAvailabilities: (
    where?: AvailabilityWhereInput
  ) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (args: {
    data: BookingUpdateInput;
    where: BookingWhereUniqueInput;
  }) => BookingPromise;
  updateManyBookings: (args: {
    data: BookingUpdateManyMutationInput;
    where?: BookingWhereInput;
  }) => BatchPayloadPromise;
  upsertBooking: (args: {
    where: BookingWhereUniqueInput;
    create: BookingCreateInput;
    update: BookingUpdateInput;
  }) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createBusinessHour: (data: BusinessHourCreateInput) => BusinessHourPromise;
  updateBusinessHour: (args: {
    data: BusinessHourUpdateInput;
    where: BusinessHourWhereUniqueInput;
  }) => BusinessHourPromise;
  updateManyBusinessHours: (args: {
    data: BusinessHourUpdateManyMutationInput;
    where?: BusinessHourWhereInput;
  }) => BatchPayloadPromise;
  upsertBusinessHour: (args: {
    where: BusinessHourWhereUniqueInput;
    create: BusinessHourCreateInput;
    update: BusinessHourUpdateInput;
  }) => BusinessHourPromise;
  deleteBusinessHour: (
    where: BusinessHourWhereUniqueInput
  ) => BusinessHourPromise;
  deleteManyBusinessHours: (
    where?: BusinessHourWhereInput
  ) => BatchPayloadPromise;
  createCharge: (data: ChargeCreateInput) => ChargePromise;
  updateCharge: (args: {
    data: ChargeUpdateInput;
    where: ChargeWhereUniqueInput;
  }) => ChargePromise;
  updateManyCharges: (args: {
    data: ChargeUpdateManyMutationInput;
    where?: ChargeWhereInput;
  }) => BatchPayloadPromise;
  upsertCharge: (args: {
    where: ChargeWhereUniqueInput;
    create: ChargeCreateInput;
    update: ChargeUpdateInput;
  }) => ChargePromise;
  deleteCharge: (where: ChargeWhereUniqueInput) => ChargePromise;
  deleteManyCharges: (where?: ChargeWhereInput) => BatchPayloadPromise;
  createContent: (data: ContentCreateInput) => ContentPromise;
  updateContent: (args: {
    data: ContentUpdateInput;
    where: ContentWhereUniqueInput;
  }) => ContentPromise;
  updateManyContents: (args: {
    data: ContentUpdateManyMutationInput;
    where?: ContentWhereInput;
  }) => BatchPayloadPromise;
  upsertContent: (args: {
    where: ContentWhereUniqueInput;
    create: ContentCreateInput;
    update: ContentUpdateInput;
  }) => ContentPromise;
  deleteContent: (where: ContentWhereUniqueInput) => ContentPromise;
  deleteManyContents: (where?: ContentWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createLastLogin: (data: LastLoginCreateInput) => LastLoginPromise;
  updateLastLogin: (args: {
    data: LastLoginUpdateInput;
    where: LastLoginWhereUniqueInput;
  }) => LastLoginPromise;
  updateManyLastLogins: (args: {
    data: LastLoginUpdateManyMutationInput;
    where?: LastLoginWhereInput;
  }) => BatchPayloadPromise;
  upsertLastLogin: (args: {
    where: LastLoginWhereUniqueInput;
    create: LastLoginCreateInput;
    update: LastLoginUpdateInput;
  }) => LastLoginPromise;
  deleteLastLogin: (where: LastLoginWhereUniqueInput) => LastLoginPromise;
  deleteManyLastLogins: (where?: LastLoginWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSessionType: (data: SessionTypeCreateInput) => SessionTypePromise;
  updateSessionType: (args: {
    data: SessionTypeUpdateInput;
    where: SessionTypeWhereUniqueInput;
  }) => SessionTypePromise;
  updateManySessionTypes: (args: {
    data: SessionTypeUpdateManyMutationInput;
    where?: SessionTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertSessionType: (args: {
    where: SessionTypeWhereUniqueInput;
    create: SessionTypeCreateInput;
    update: SessionTypeUpdateInput;
  }) => SessionTypePromise;
  deleteSessionType: (where: SessionTypeWhereUniqueInput) => SessionTypePromise;
  deleteManySessionTypes: (
    where?: SessionTypeWhereInput
  ) => BatchPayloadPromise;
  createStripeAccount: (data: StripeAccountCreateInput) => StripeAccountPromise;
  updateStripeAccount: (args: {
    data: StripeAccountUpdateInput;
    where: StripeAccountWhereUniqueInput;
  }) => StripeAccountPromise;
  updateManyStripeAccounts: (args: {
    data: StripeAccountUpdateManyMutationInput;
    where?: StripeAccountWhereInput;
  }) => BatchPayloadPromise;
  upsertStripeAccount: (args: {
    where: StripeAccountWhereUniqueInput;
    create: StripeAccountCreateInput;
    update: StripeAccountUpdateInput;
  }) => StripeAccountPromise;
  deleteStripeAccount: (
    where: StripeAccountWhereUniqueInput
  ) => StripeAccountPromise;
  deleteManyStripeAccounts: (
    where?: StripeAccountWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activity: (
    where?: ActivitySubscriptionWhereInput
  ) => ActivitySubscriptionPayloadSubscription;
  availability: (
    where?: AvailabilitySubscriptionWhereInput
  ) => AvailabilitySubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  businessHour: (
    where?: BusinessHourSubscriptionWhereInput
  ) => BusinessHourSubscriptionPayloadSubscription;
  charge: (
    where?: ChargeSubscriptionWhereInput
  ) => ChargeSubscriptionPayloadSubscription;
  content: (
    where?: ContentSubscriptionWhereInput
  ) => ContentSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  lastLogin: (
    where?: LastLoginSubscriptionWhereInput
  ) => LastLoginSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  sessionType: (
    where?: SessionTypeSubscriptionWhereInput
  ) => SessionTypeSubscriptionPayloadSubscription;
  stripeAccount: (
    where?: StripeAccountSubscriptionWhereInput
  ) => StripeAccountSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Role = "ADMIN" | "COACH" | "CUSTOMER";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailToken_ASC"
  | "emailToken_DESC"
  | "emailTokenExpiry_ASC"
  | "emailTokenExpiry_DESC"
  | "inviteToken_ASC"
  | "inviteToken_DESC"
  | "inviteTokenExpiry_ASC"
  | "inviteTokenExpiry_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "role_ASC"
  | "role_DESC"
  | "name_ASC"
  | "name_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "timezone_ASC"
  | "timezone_DESC"
  | "backgroundColor_ASC"
  | "backgroundColor_DESC"
  | "biography_ASC"
  | "biography_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "website_ASC"
  | "website_DESC"
  | "mobile_ASC"
  | "mobile_DESC";

export type SessionTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "maxSeats_ASC"
  | "maxSeats_DESC"
  | "cost_ASC"
  | "cost_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "location_ASC"
  | "location_DESC"
  | "link_ASC"
  | "link_DESC"
  | "recurring_ASC"
  | "recurring_DESC"
  | "maxSeats_ASC"
  | "maxSeats_DESC"
  | "singleEvent_ASC"
  | "singleEvent_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "cost_ASC"
  | "cost_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "timeSlot_ASC"
  | "timeSlot_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "role_ASC"
  | "role_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailToken_ASC"
  | "emailToken_DESC"
  | "emailTokenExpiry_ASC"
  | "emailTokenExpiry_DESC"
  | "inviteToken_ASC"
  | "inviteToken_DESC"
  | "inviteTokenExpiry_ASC"
  | "inviteTokenExpiry_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC";

export type AvailabilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC";

export type BusinessHourOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC";

export type ChargeOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "stripe_user_id_ASC"
  | "stripe_user_id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "amount_refunded_ASC"
  | "amount_refunded_DESC"
  | "application_fee_amount_ASC"
  | "application_fee_amount_DESC"
  | "description_ASC"
  | "description_DESC"
  | "receipt_url_ASC"
  | "receipt_url_DESC"
  | "refunded_ASC"
  | "refunded_DESC"
  | "currency_ASC"
  | "currency_DESC";

export type ContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "message_ASC"
  | "message_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "width_ASC"
  | "width_DESC"
  | "height_ASC"
  | "height_DESC";

export type LastLoginOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "action_ASC"
  | "action_DESC";

export type StripeAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "stripe_user_id_ASC"
  | "stripe_user_id_DESC"
  | "access_token_ASC"
  | "access_token_DESC"
  | "scope_ASC"
  | "scope_DESC"
  | "livemode_ASC"
  | "livemode_DESC"
  | "token_type_ASC"
  | "token_type_DESC"
  | "refresh_token_ASC"
  | "refresh_token_DESC"
  | "stripe_publishable_key_ASC"
  | "stripe_publishable_key_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailToken_not?: Maybe<String>;
  emailToken_in?: Maybe<String[] | String>;
  emailToken_not_in?: Maybe<String[] | String>;
  emailToken_lt?: Maybe<String>;
  emailToken_lte?: Maybe<String>;
  emailToken_gt?: Maybe<String>;
  emailToken_gte?: Maybe<String>;
  emailToken_contains?: Maybe<String>;
  emailToken_not_contains?: Maybe<String>;
  emailToken_starts_with?: Maybe<String>;
  emailToken_not_starts_with?: Maybe<String>;
  emailToken_ends_with?: Maybe<String>;
  emailToken_not_ends_with?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  emailTokenExpiry_not?: Maybe<Float>;
  emailTokenExpiry_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_lt?: Maybe<Float>;
  emailTokenExpiry_lte?: Maybe<Float>;
  emailTokenExpiry_gt?: Maybe<Float>;
  emailTokenExpiry_gte?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteToken_not?: Maybe<String>;
  inviteToken_in?: Maybe<String[] | String>;
  inviteToken_not_in?: Maybe<String[] | String>;
  inviteToken_lt?: Maybe<String>;
  inviteToken_lte?: Maybe<String>;
  inviteToken_gt?: Maybe<String>;
  inviteToken_gte?: Maybe<String>;
  inviteToken_contains?: Maybe<String>;
  inviteToken_not_contains?: Maybe<String>;
  inviteToken_starts_with?: Maybe<String>;
  inviteToken_not_starts_with?: Maybe<String>;
  inviteToken_ends_with?: Maybe<String>;
  inviteToken_not_ends_with?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  inviteTokenExpiry_not?: Maybe<Float>;
  inviteTokenExpiry_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_not_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_lt?: Maybe<Float>;
  inviteTokenExpiry_lte?: Maybe<Float>;
  inviteTokenExpiry_gt?: Maybe<Float>;
  inviteTokenExpiry_gte?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  coaches_some?: Maybe<UserWhereInput>;
  sessionTypes_some?: Maybe<SessionTypeWhereInput>;
  lastLogin?: Maybe<LastLoginWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  timezone?: Maybe<String>;
  timezone_not?: Maybe<String>;
  timezone_in?: Maybe<String[] | String>;
  timezone_not_in?: Maybe<String[] | String>;
  timezone_lt?: Maybe<String>;
  timezone_lte?: Maybe<String>;
  timezone_gt?: Maybe<String>;
  timezone_gte?: Maybe<String>;
  timezone_contains?: Maybe<String>;
  timezone_not_contains?: Maybe<String>;
  timezone_starts_with?: Maybe<String>;
  timezone_not_starts_with?: Maybe<String>;
  timezone_ends_with?: Maybe<String>;
  timezone_not_ends_with?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  backgroundColor_not?: Maybe<String>;
  backgroundColor_in?: Maybe<String[] | String>;
  backgroundColor_not_in?: Maybe<String[] | String>;
  backgroundColor_lt?: Maybe<String>;
  backgroundColor_lte?: Maybe<String>;
  backgroundColor_gt?: Maybe<String>;
  backgroundColor_gte?: Maybe<String>;
  backgroundColor_contains?: Maybe<String>;
  backgroundColor_not_contains?: Maybe<String>;
  backgroundColor_starts_with?: Maybe<String>;
  backgroundColor_not_starts_with?: Maybe<String>;
  backgroundColor_ends_with?: Maybe<String>;
  backgroundColor_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<ImageWhereInput>;
  coverImage?: Maybe<ImageWhereInput>;
  stripeAccount?: Maybe<StripeAccountWhereInput>;
  activities_some?: Maybe<ActivityWhereInput>;
  customers_some?: Maybe<CustomerWhereInput>;
  biography?: Maybe<String>;
  biography_not?: Maybe<String>;
  biography_in?: Maybe<String[] | String>;
  biography_not_in?: Maybe<String[] | String>;
  biography_lt?: Maybe<String>;
  biography_lte?: Maybe<String>;
  biography_gt?: Maybe<String>;
  biography_gte?: Maybe<String>;
  biography_contains?: Maybe<String>;
  biography_not_contains?: Maybe<String>;
  biography_starts_with?: Maybe<String>;
  biography_not_starts_with?: Maybe<String>;
  biography_ends_with?: Maybe<String>;
  biography_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  twitter?: Maybe<String>;
  twitter_not?: Maybe<String>;
  twitter_in?: Maybe<String[] | String>;
  twitter_not_in?: Maybe<String[] | String>;
  twitter_lt?: Maybe<String>;
  twitter_lte?: Maybe<String>;
  twitter_gt?: Maybe<String>;
  twitter_gte?: Maybe<String>;
  twitter_contains?: Maybe<String>;
  twitter_not_contains?: Maybe<String>;
  twitter_starts_with?: Maybe<String>;
  twitter_not_starts_with?: Maybe<String>;
  twitter_ends_with?: Maybe<String>;
  twitter_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface SessionTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  coach?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  maxSeats_not?: Maybe<Int>;
  maxSeats_in?: Maybe<Int[] | Int>;
  maxSeats_not_in?: Maybe<Int[] | Int>;
  maxSeats_lt?: Maybe<Int>;
  maxSeats_lte?: Maybe<Int>;
  maxSeats_gt?: Maybe<Int>;
  maxSeats_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  sessions_some?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionTypeWhereInput[] | SessionTypeWhereInput>;
}

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  coach?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  sessionType?: Maybe<SessionTypeWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  recurring_not?: Maybe<Boolean>;
  availability?: Maybe<AvailabilityWhereInput>;
  maxSeats?: Maybe<Int>;
  maxSeats_not?: Maybe<Int>;
  maxSeats_in?: Maybe<Int[] | Int>;
  maxSeats_not_in?: Maybe<Int[] | Int>;
  maxSeats_lt?: Maybe<Int>;
  maxSeats_lte?: Maybe<Int>;
  maxSeats_gt?: Maybe<Int>;
  maxSeats_gte?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  singleEvent_not?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  bookings_some?: Maybe<BookingWhereInput>;
  coverImage?: Maybe<ImageWhereInput>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface AvailabilityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<DateTimeInput>;
  start_not?: Maybe<DateTimeInput>;
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_lt?: Maybe<DateTimeInput>;
  start_lte?: Maybe<DateTimeInput>;
  start_gt?: Maybe<DateTimeInput>;
  start_gte?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  end_not?: Maybe<DateTimeInput>;
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_lt?: Maybe<DateTimeInput>;
  end_lte?: Maybe<DateTimeInput>;
  end_gt?: Maybe<DateTimeInput>;
  end_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AvailabilityWhereInput[] | AvailabilityWhereInput>;
}

export interface BusinessHourWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<BusinessHourWhereInput[] | BusinessHourWhereInput>;
}

export interface BookingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  session?: Maybe<SessionWhereInput>;
  timeSlot?: Maybe<String>;
  timeSlot_not?: Maybe<String>;
  timeSlot_in?: Maybe<String[] | String>;
  timeSlot_not_in?: Maybe<String[] | String>;
  timeSlot_lt?: Maybe<String>;
  timeSlot_lte?: Maybe<String>;
  timeSlot_gt?: Maybe<String>;
  timeSlot_gte?: Maybe<String>;
  timeSlot_contains?: Maybe<String>;
  timeSlot_not_contains?: Maybe<String>;
  timeSlot_starts_with?: Maybe<String>;
  timeSlot_not_starts_with?: Maybe<String>;
  timeSlot_ends_with?: Maybe<String>;
  timeSlot_not_ends_with?: Maybe<String>;
  charge?: Maybe<ChargeWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookingWhereInput[] | BookingWhereInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  coach?: Maybe<UserWhereInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailToken_not?: Maybe<String>;
  emailToken_in?: Maybe<String[] | String>;
  emailToken_not_in?: Maybe<String[] | String>;
  emailToken_lt?: Maybe<String>;
  emailToken_lte?: Maybe<String>;
  emailToken_gt?: Maybe<String>;
  emailToken_gte?: Maybe<String>;
  emailToken_contains?: Maybe<String>;
  emailToken_not_contains?: Maybe<String>;
  emailToken_starts_with?: Maybe<String>;
  emailToken_not_starts_with?: Maybe<String>;
  emailToken_ends_with?: Maybe<String>;
  emailToken_not_ends_with?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  emailTokenExpiry_not?: Maybe<Float>;
  emailTokenExpiry_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_lt?: Maybe<Float>;
  emailTokenExpiry_lte?: Maybe<Float>;
  emailTokenExpiry_gt?: Maybe<Float>;
  emailTokenExpiry_gte?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteToken_not?: Maybe<String>;
  inviteToken_in?: Maybe<String[] | String>;
  inviteToken_not_in?: Maybe<String[] | String>;
  inviteToken_lt?: Maybe<String>;
  inviteToken_lte?: Maybe<String>;
  inviteToken_gt?: Maybe<String>;
  inviteToken_gte?: Maybe<String>;
  inviteToken_contains?: Maybe<String>;
  inviteToken_not_contains?: Maybe<String>;
  inviteToken_starts_with?: Maybe<String>;
  inviteToken_not_starts_with?: Maybe<String>;
  inviteToken_ends_with?: Maybe<String>;
  inviteToken_not_ends_with?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  inviteTokenExpiry_not?: Maybe<Float>;
  inviteTokenExpiry_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_not_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_lt?: Maybe<Float>;
  inviteTokenExpiry_lte?: Maybe<Float>;
  inviteTokenExpiry_gt?: Maybe<Float>;
  inviteTokenExpiry_gte?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<ImageWhereInput>;
  coverImage?: Maybe<ImageWhereInput>;
  stripeAccount?: Maybe<StripeAccountWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  width?: Maybe<Int>;
  width_not?: Maybe<Int>;
  width_in?: Maybe<Int[] | Int>;
  width_not_in?: Maybe<Int[] | Int>;
  width_lt?: Maybe<Int>;
  width_lte?: Maybe<Int>;
  width_gt?: Maybe<Int>;
  width_gte?: Maybe<Int>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface StripeAccountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  stripe_user_id?: Maybe<String>;
  stripe_user_id_not?: Maybe<String>;
  stripe_user_id_in?: Maybe<String[] | String>;
  stripe_user_id_not_in?: Maybe<String[] | String>;
  stripe_user_id_lt?: Maybe<String>;
  stripe_user_id_lte?: Maybe<String>;
  stripe_user_id_gt?: Maybe<String>;
  stripe_user_id_gte?: Maybe<String>;
  stripe_user_id_contains?: Maybe<String>;
  stripe_user_id_not_contains?: Maybe<String>;
  stripe_user_id_starts_with?: Maybe<String>;
  stripe_user_id_not_starts_with?: Maybe<String>;
  stripe_user_id_ends_with?: Maybe<String>;
  stripe_user_id_not_ends_with?: Maybe<String>;
  access_token?: Maybe<String>;
  access_token_not?: Maybe<String>;
  access_token_in?: Maybe<String[] | String>;
  access_token_not_in?: Maybe<String[] | String>;
  access_token_lt?: Maybe<String>;
  access_token_lte?: Maybe<String>;
  access_token_gt?: Maybe<String>;
  access_token_gte?: Maybe<String>;
  access_token_contains?: Maybe<String>;
  access_token_not_contains?: Maybe<String>;
  access_token_starts_with?: Maybe<String>;
  access_token_not_starts_with?: Maybe<String>;
  access_token_ends_with?: Maybe<String>;
  access_token_not_ends_with?: Maybe<String>;
  scope?: Maybe<String>;
  scope_not?: Maybe<String>;
  scope_in?: Maybe<String[] | String>;
  scope_not_in?: Maybe<String[] | String>;
  scope_lt?: Maybe<String>;
  scope_lte?: Maybe<String>;
  scope_gt?: Maybe<String>;
  scope_gte?: Maybe<String>;
  scope_contains?: Maybe<String>;
  scope_not_contains?: Maybe<String>;
  scope_starts_with?: Maybe<String>;
  scope_not_starts_with?: Maybe<String>;
  scope_ends_with?: Maybe<String>;
  scope_not_ends_with?: Maybe<String>;
  livemode?: Maybe<Boolean>;
  livemode_not?: Maybe<Boolean>;
  token_type?: Maybe<String>;
  token_type_not?: Maybe<String>;
  token_type_in?: Maybe<String[] | String>;
  token_type_not_in?: Maybe<String[] | String>;
  token_type_lt?: Maybe<String>;
  token_type_lte?: Maybe<String>;
  token_type_gt?: Maybe<String>;
  token_type_gte?: Maybe<String>;
  token_type_contains?: Maybe<String>;
  token_type_not_contains?: Maybe<String>;
  token_type_starts_with?: Maybe<String>;
  token_type_not_starts_with?: Maybe<String>;
  token_type_ends_with?: Maybe<String>;
  token_type_not_ends_with?: Maybe<String>;
  refresh_token?: Maybe<String>;
  refresh_token_not?: Maybe<String>;
  refresh_token_in?: Maybe<String[] | String>;
  refresh_token_not_in?: Maybe<String[] | String>;
  refresh_token_lt?: Maybe<String>;
  refresh_token_lte?: Maybe<String>;
  refresh_token_gt?: Maybe<String>;
  refresh_token_gte?: Maybe<String>;
  refresh_token_contains?: Maybe<String>;
  refresh_token_not_contains?: Maybe<String>;
  refresh_token_starts_with?: Maybe<String>;
  refresh_token_not_starts_with?: Maybe<String>;
  refresh_token_ends_with?: Maybe<String>;
  refresh_token_not_ends_with?: Maybe<String>;
  stripe_publishable_key?: Maybe<String>;
  stripe_publishable_key_not?: Maybe<String>;
  stripe_publishable_key_in?: Maybe<String[] | String>;
  stripe_publishable_key_not_in?: Maybe<String[] | String>;
  stripe_publishable_key_lt?: Maybe<String>;
  stripe_publishable_key_lte?: Maybe<String>;
  stripe_publishable_key_gt?: Maybe<String>;
  stripe_publishable_key_gte?: Maybe<String>;
  stripe_publishable_key_contains?: Maybe<String>;
  stripe_publishable_key_not_contains?: Maybe<String>;
  stripe_publishable_key_starts_with?: Maybe<String>;
  stripe_publishable_key_not_starts_with?: Maybe<String>;
  stripe_publishable_key_ends_with?: Maybe<String>;
  stripe_publishable_key_not_ends_with?: Maybe<String>;
  AND?: Maybe<StripeAccountWhereInput[] | StripeAccountWhereInput>;
}

export interface ChargeWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  coach?: Maybe<UserWhereInput>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  stripe_user_id?: Maybe<String>;
  stripe_user_id_not?: Maybe<String>;
  stripe_user_id_in?: Maybe<String[] | String>;
  stripe_user_id_not_in?: Maybe<String[] | String>;
  stripe_user_id_lt?: Maybe<String>;
  stripe_user_id_lte?: Maybe<String>;
  stripe_user_id_gt?: Maybe<String>;
  stripe_user_id_gte?: Maybe<String>;
  stripe_user_id_contains?: Maybe<String>;
  stripe_user_id_not_contains?: Maybe<String>;
  stripe_user_id_starts_with?: Maybe<String>;
  stripe_user_id_not_starts_with?: Maybe<String>;
  stripe_user_id_ends_with?: Maybe<String>;
  stripe_user_id_not_ends_with?: Maybe<String>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  amount_refunded?: Maybe<Float>;
  amount_refunded_not?: Maybe<Float>;
  amount_refunded_in?: Maybe<Float[] | Float>;
  amount_refunded_not_in?: Maybe<Float[] | Float>;
  amount_refunded_lt?: Maybe<Float>;
  amount_refunded_lte?: Maybe<Float>;
  amount_refunded_gt?: Maybe<Float>;
  amount_refunded_gte?: Maybe<Float>;
  application_fee_amount?: Maybe<Float>;
  application_fee_amount_not?: Maybe<Float>;
  application_fee_amount_in?: Maybe<Float[] | Float>;
  application_fee_amount_not_in?: Maybe<Float[] | Float>;
  application_fee_amount_lt?: Maybe<Float>;
  application_fee_amount_lte?: Maybe<Float>;
  application_fee_amount_gt?: Maybe<Float>;
  application_fee_amount_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  receipt_url?: Maybe<String>;
  receipt_url_not?: Maybe<String>;
  receipt_url_in?: Maybe<String[] | String>;
  receipt_url_not_in?: Maybe<String[] | String>;
  receipt_url_lt?: Maybe<String>;
  receipt_url_lte?: Maybe<String>;
  receipt_url_gt?: Maybe<String>;
  receipt_url_gte?: Maybe<String>;
  receipt_url_contains?: Maybe<String>;
  receipt_url_not_contains?: Maybe<String>;
  receipt_url_starts_with?: Maybe<String>;
  receipt_url_not_starts_with?: Maybe<String>;
  receipt_url_ends_with?: Maybe<String>;
  receipt_url_not_ends_with?: Maybe<String>;
  refunded?: Maybe<Boolean>;
  refunded_not?: Maybe<Boolean>;
  currency?: Maybe<String>;
  currency_not?: Maybe<String>;
  currency_in?: Maybe<String[] | String>;
  currency_not_in?: Maybe<String[] | String>;
  currency_lt?: Maybe<String>;
  currency_lte?: Maybe<String>;
  currency_gt?: Maybe<String>;
  currency_gte?: Maybe<String>;
  currency_contains?: Maybe<String>;
  currency_not_contains?: Maybe<String>;
  currency_starts_with?: Maybe<String>;
  currency_not_starts_with?: Maybe<String>;
  currency_ends_with?: Maybe<String>;
  currency_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChargeWhereInput[] | ChargeWhereInput>;
}

export interface LastLoginWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  AND?: Maybe<LastLoginWhereInput[] | LastLoginWhereInput>;
}

export interface ActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<ActivityWhereInput[] | ActivityWhereInput>;
}

export interface ContentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContentWhereInput[] | ContentWhereInput>;
}

export type AvailabilityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BookingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type BusinessHourWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ChargeWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
  id?: Maybe<String>;
}>;

export type ContentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  emailToken?: Maybe<String>;
}>;

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LastLoginWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SessionTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type StripeAccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface ActivityCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutActivitiesInput>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface UserCreateOneWithoutActivitiesInput {
  create?: Maybe<UserCreateWithoutActivitiesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutActivitiesInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserCreateManyInput>;
  sessionTypes?: Maybe<SessionTypeCreateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginCreateOneInput>;
  name: String;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
  customers?: Maybe<CustomerCreateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserCreateManyInput>;
  sessionTypes?: Maybe<SessionTypeCreateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginCreateOneInput>;
  name: String;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
  activities?: Maybe<ActivityCreateManyWithoutUserInput>;
  customers?: Maybe<CustomerCreateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface SessionTypeCreateManyWithoutCoachInput {
  create?: Maybe<
    SessionTypeCreateWithoutCoachInput[] | SessionTypeCreateWithoutCoachInput
  >;
  connect?: Maybe<SessionTypeWhereUniqueInput[] | SessionTypeWhereUniqueInput>;
}

export interface SessionTypeCreateWithoutCoachInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost: Int;
  sessions?: Maybe<SessionCreateManyWithoutSessionTypeInput>;
}

export interface SessionCreateManyWithoutSessionTypeInput {
  create?: Maybe<
    | SessionCreateWithoutSessionTypeInput[]
    | SessionCreateWithoutSessionTypeInput
  >;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
}

export interface SessionCreateWithoutSessionTypeInput {
  id?: Maybe<ID_Input>;
  coach?: Maybe<UserCreateOneInput>;
  name: String;
  description?: Maybe<String>;
  location: String;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability: AvailabilityCreateOneInput;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourCreateOneInput>;
  duration: Int;
  bookings?: Maybe<BookingCreateManyWithoutSessionInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  cost?: Maybe<Int>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AvailabilityCreateOneInput {
  create?: Maybe<AvailabilityCreateInput>;
  connect?: Maybe<AvailabilityWhereUniqueInput>;
}

export interface AvailabilityCreateInput {
  id?: Maybe<ID_Input>;
  start: DateTimeInput;
  end: DateTimeInput;
}

export interface BusinessHourCreateOneInput {
  create?: Maybe<BusinessHourCreateInput>;
  connect?: Maybe<BusinessHourWhereUniqueInput>;
}

export interface BusinessHourCreateInput {
  id?: Maybe<ID_Input>;
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface BookingCreateManyWithoutSessionInput {
  create?: Maybe<
    BookingCreateWithoutSessionInput[] | BookingCreateWithoutSessionInput
  >;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
}

export interface BookingCreateWithoutSessionInput {
  id?: Maybe<ID_Input>;
  customer?: Maybe<CustomerCreateOneInput>;
  timeSlot?: Maybe<String>;
  charge?: Maybe<ChargeCreateOneInput>;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  coach: UserCreateOneWithoutCustomersInput;
  role?: Maybe<Role>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name: String;
  password?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
}

export interface UserCreateOneWithoutCustomersInput {
  create?: Maybe<UserCreateWithoutCustomersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCustomersInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserCreateManyInput>;
  sessionTypes?: Maybe<SessionTypeCreateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginCreateOneInput>;
  name: String;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
  activities?: Maybe<ActivityCreateManyWithoutUserInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface LastLoginCreateOneInput {
  create?: Maybe<LastLoginCreateInput>;
  connect?: Maybe<LastLoginWhereUniqueInput>;
}

export interface LastLoginCreateInput {
  id?: Maybe<ID_Input>;
  action: String;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  width: Int;
  height: Int;
}

export interface StripeAccountCreateOneInput {
  create?: Maybe<StripeAccountCreateInput>;
  connect?: Maybe<StripeAccountWhereUniqueInput>;
}

export interface StripeAccountCreateInput {
  id?: Maybe<ID_Input>;
  stripe_user_id: String;
  access_token: String;
  scope: String;
  livemode: Boolean;
  token_type: String;
  refresh_token: String;
  stripe_publishable_key: String;
}

export interface ActivityCreateManyWithoutUserInput {
  create?: Maybe<
    ActivityCreateWithoutUserInput[] | ActivityCreateWithoutUserInput
  >;
  connect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
}

export interface ActivityCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface ContentCreateOneInput {
  create?: Maybe<ContentCreateInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ContentCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<String>;
  message?: Maybe<String>;
}

export interface ChargeCreateOneInput {
  create?: Maybe<ChargeCreateInput>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface ChargeCreateInput {
  _id?: Maybe<ID_Input>;
  coach: UserCreateOneInput;
  id: String;
  stripe_user_id: String;
  amount: Float;
  amount_refunded: Float;
  application_fee_amount?: Maybe<Float>;
  description?: Maybe<String>;
  receipt_url: String;
  refunded: Boolean;
  currency: String;
}

export interface CustomerCreateManyWithoutCoachInput {
  create?: Maybe<
    CustomerCreateWithoutCoachInput[] | CustomerCreateWithoutCoachInput
  >;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutCoachInput {
  id?: Maybe<ID_Input>;
  role?: Maybe<Role>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name: String;
  password?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
}

export interface ActivityUpdateInput {
  user?: Maybe<UserUpdateOneWithoutActivitiesInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface UserUpdateOneWithoutActivitiesInput {
  create?: Maybe<UserCreateWithoutActivitiesInput>;
  update?: Maybe<UserUpdateWithoutActivitiesDataInput>;
  upsert?: Maybe<UserUpsertWithoutActivitiesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutActivitiesDataInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserUpdateManyInput>;
  sessionTypes?: Maybe<SessionTypeUpdateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginUpdateOneInput>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
  customers?: Maybe<CustomerUpdateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserUpdateManyInput>;
  sessionTypes?: Maybe<SessionTypeUpdateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginUpdateOneInput>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
  activities?: Maybe<ActivityUpdateManyWithoutUserInput>;
  customers?: Maybe<CustomerUpdateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface SessionTypeUpdateManyWithoutCoachInput {
  create?: Maybe<
    SessionTypeCreateWithoutCoachInput[] | SessionTypeCreateWithoutCoachInput
  >;
  delete?: Maybe<SessionTypeWhereUniqueInput[] | SessionTypeWhereUniqueInput>;
  connect?: Maybe<SessionTypeWhereUniqueInput[] | SessionTypeWhereUniqueInput>;
  set?: Maybe<SessionTypeWhereUniqueInput[] | SessionTypeWhereUniqueInput>;
  disconnect?: Maybe<
    SessionTypeWhereUniqueInput[] | SessionTypeWhereUniqueInput
  >;
  update?: Maybe<
    | SessionTypeUpdateWithWhereUniqueWithoutCoachInput[]
    | SessionTypeUpdateWithWhereUniqueWithoutCoachInput
  >;
  upsert?: Maybe<
    | SessionTypeUpsertWithWhereUniqueWithoutCoachInput[]
    | SessionTypeUpsertWithWhereUniqueWithoutCoachInput
  >;
  deleteMany?: Maybe<
    SessionTypeScalarWhereInput[] | SessionTypeScalarWhereInput
  >;
  updateMany?: Maybe<
    | SessionTypeUpdateManyWithWhereNestedInput[]
    | SessionTypeUpdateManyWithWhereNestedInput
  >;
}

export interface SessionTypeUpdateWithWhereUniqueWithoutCoachInput {
  where: SessionTypeWhereUniqueInput;
  data: SessionTypeUpdateWithoutCoachDataInput;
}

export interface SessionTypeUpdateWithoutCoachDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost?: Maybe<Int>;
  sessions?: Maybe<SessionUpdateManyWithoutSessionTypeInput>;
}

export interface SessionUpdateManyWithoutSessionTypeInput {
  create?: Maybe<
    | SessionCreateWithoutSessionTypeInput[]
    | SessionCreateWithoutSessionTypeInput
  >;
  delete?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  connect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  set?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  disconnect?: Maybe<SessionWhereUniqueInput[] | SessionWhereUniqueInput>;
  update?: Maybe<
    | SessionUpdateWithWhereUniqueWithoutSessionTypeInput[]
    | SessionUpdateWithWhereUniqueWithoutSessionTypeInput
  >;
  upsert?: Maybe<
    | SessionUpsertWithWhereUniqueWithoutSessionTypeInput[]
    | SessionUpsertWithWhereUniqueWithoutSessionTypeInput
  >;
  deleteMany?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  updateMany?: Maybe<
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput
  >;
}

export interface SessionUpdateWithWhereUniqueWithoutSessionTypeInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateWithoutSessionTypeDataInput;
}

export interface SessionUpdateWithoutSessionTypeDataInput {
  coach?: Maybe<UserUpdateOneInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability?: Maybe<AvailabilityUpdateOneRequiredInput>;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourUpdateOneInput>;
  duration?: Maybe<Int>;
  bookings?: Maybe<BookingUpdateManyWithoutSessionInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  cost?: Maybe<Int>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface AvailabilityUpdateOneRequiredInput {
  create?: Maybe<AvailabilityCreateInput>;
  update?: Maybe<AvailabilityUpdateDataInput>;
  upsert?: Maybe<AvailabilityUpsertNestedInput>;
  connect?: Maybe<AvailabilityWhereUniqueInput>;
}

export interface AvailabilityUpdateDataInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface AvailabilityUpsertNestedInput {
  update: AvailabilityUpdateDataInput;
  create: AvailabilityCreateInput;
}

export interface BusinessHourUpdateOneInput {
  create?: Maybe<BusinessHourCreateInput>;
  update?: Maybe<BusinessHourUpdateDataInput>;
  upsert?: Maybe<BusinessHourUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BusinessHourWhereUniqueInput>;
}

export interface BusinessHourUpdateDataInput {
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface BusinessHourUpsertNestedInput {
  update: BusinessHourUpdateDataInput;
  create: BusinessHourCreateInput;
}

export interface BookingUpdateManyWithoutSessionInput {
  create?: Maybe<
    BookingCreateWithoutSessionInput[] | BookingCreateWithoutSessionInput
  >;
  delete?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  set?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  disconnect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  update?: Maybe<
    | BookingUpdateWithWhereUniqueWithoutSessionInput[]
    | BookingUpdateWithWhereUniqueWithoutSessionInput
  >;
  upsert?: Maybe<
    | BookingUpsertWithWhereUniqueWithoutSessionInput[]
    | BookingUpsertWithWhereUniqueWithoutSessionInput
  >;
  deleteMany?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  updateMany?: Maybe<
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput
  >;
}

export interface BookingUpdateWithWhereUniqueWithoutSessionInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutSessionDataInput;
}

export interface BookingUpdateWithoutSessionDataInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  timeSlot?: Maybe<String>;
  charge?: Maybe<ChargeUpdateOneInput>;
}

export interface CustomerUpdateOneInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateDataInput {
  coach?: Maybe<UserUpdateOneRequiredWithoutCustomersInput>;
  role?: Maybe<Role>;
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
}

export interface UserUpdateOneRequiredWithoutCustomersInput {
  create?: Maybe<UserCreateWithoutCustomersInput>;
  update?: Maybe<UserUpdateWithoutCustomersDataInput>;
  upsert?: Maybe<UserUpsertWithoutCustomersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCustomersDataInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserUpdateManyInput>;
  sessionTypes?: Maybe<SessionTypeUpdateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginUpdateOneInput>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
  activities?: Maybe<ActivityUpdateManyWithoutUserInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface LastLoginUpdateOneInput {
  create?: Maybe<LastLoginCreateInput>;
  update?: Maybe<LastLoginUpdateDataInput>;
  upsert?: Maybe<LastLoginUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LastLoginWhereUniqueInput>;
}

export interface LastLoginUpdateDataInput {
  action?: Maybe<String>;
}

export interface LastLoginUpsertNestedInput {
  update: LastLoginUpdateDataInput;
  create: LastLoginCreateInput;
}

export interface ImageUpdateOneInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageUpdateDataInput {
  url?: Maybe<String>;
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface StripeAccountUpdateOneInput {
  create?: Maybe<StripeAccountCreateInput>;
  update?: Maybe<StripeAccountUpdateDataInput>;
  upsert?: Maybe<StripeAccountUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StripeAccountWhereUniqueInput>;
}

export interface StripeAccountUpdateDataInput {
  stripe_user_id?: Maybe<String>;
  access_token?: Maybe<String>;
  scope?: Maybe<String>;
  livemode?: Maybe<Boolean>;
  token_type?: Maybe<String>;
  refresh_token?: Maybe<String>;
  stripe_publishable_key?: Maybe<String>;
}

export interface StripeAccountUpsertNestedInput {
  update: StripeAccountUpdateDataInput;
  create: StripeAccountCreateInput;
}

export interface ActivityUpdateManyWithoutUserInput {
  create?: Maybe<
    ActivityCreateWithoutUserInput[] | ActivityCreateWithoutUserInput
  >;
  delete?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  connect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  set?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  disconnect?: Maybe<ActivityWhereUniqueInput[] | ActivityWhereUniqueInput>;
  update?: Maybe<
    | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    | ActivityUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    | ActivityUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
}

export interface ActivityUpdateWithWhereUniqueWithoutUserInput {
  where: ActivityWhereUniqueInput;
  data: ActivityUpdateWithoutUserDataInput;
}

export interface ActivityUpdateWithoutUserDataInput {
  content?: Maybe<ContentUpdateOneInput>;
}

export interface ContentUpdateOneInput {
  create?: Maybe<ContentCreateInput>;
  update?: Maybe<ContentUpdateDataInput>;
  upsert?: Maybe<ContentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ContentUpdateDataInput {
  type?: Maybe<String>;
  message?: Maybe<String>;
}

export interface ContentUpsertNestedInput {
  update: ContentUpdateDataInput;
  create: ContentCreateInput;
}

export interface ActivityUpsertWithWhereUniqueWithoutUserInput {
  where: ActivityWhereUniqueInput;
  update: ActivityUpdateWithoutUserDataInput;
  create: ActivityCreateWithoutUserInput;
}

export interface ActivityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
  OR?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
  NOT?: Maybe<ActivityScalarWhereInput[] | ActivityScalarWhereInput>;
}

export interface UserUpsertWithoutCustomersInput {
  update: UserUpdateWithoutCustomersDataInput;
  create: UserCreateWithoutCustomersInput;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface ChargeUpdateOneInput {
  create?: Maybe<ChargeCreateInput>;
  update?: Maybe<ChargeUpdateDataInput>;
  upsert?: Maybe<ChargeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface ChargeUpdateDataInput {
  coach?: Maybe<UserUpdateOneRequiredInput>;
  id?: Maybe<String>;
  stripe_user_id?: Maybe<String>;
  amount?: Maybe<Float>;
  amount_refunded?: Maybe<Float>;
  application_fee_amount?: Maybe<Float>;
  description?: Maybe<String>;
  receipt_url?: Maybe<String>;
  refunded?: Maybe<Boolean>;
  currency?: Maybe<String>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ChargeUpsertNestedInput {
  update: ChargeUpdateDataInput;
  create: ChargeCreateInput;
}

export interface BookingUpsertWithWhereUniqueWithoutSessionInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutSessionDataInput;
  create: BookingCreateWithoutSessionInput;
}

export interface BookingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  timeSlot?: Maybe<String>;
  timeSlot_not?: Maybe<String>;
  timeSlot_in?: Maybe<String[] | String>;
  timeSlot_not_in?: Maybe<String[] | String>;
  timeSlot_lt?: Maybe<String>;
  timeSlot_lte?: Maybe<String>;
  timeSlot_gt?: Maybe<String>;
  timeSlot_gte?: Maybe<String>;
  timeSlot_contains?: Maybe<String>;
  timeSlot_not_contains?: Maybe<String>;
  timeSlot_starts_with?: Maybe<String>;
  timeSlot_not_starts_with?: Maybe<String>;
  timeSlot_ends_with?: Maybe<String>;
  timeSlot_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  OR?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  NOT?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface BookingUpdateManyDataInput {
  timeSlot?: Maybe<String>;
}

export interface SessionUpsertWithWhereUniqueWithoutSessionTypeInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateWithoutSessionTypeDataInput;
  create: SessionCreateWithoutSessionTypeInput;
}

export interface SessionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  recurring_not?: Maybe<Boolean>;
  maxSeats?: Maybe<Int>;
  maxSeats_not?: Maybe<Int>;
  maxSeats_in?: Maybe<Int[] | Int>;
  maxSeats_not_in?: Maybe<Int[] | Int>;
  maxSeats_lt?: Maybe<Int>;
  maxSeats_lte?: Maybe<Int>;
  maxSeats_gt?: Maybe<Int>;
  maxSeats_gte?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  singleEvent_not?: Maybe<Boolean>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  OR?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  NOT?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
}

export interface SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput;
  data: SessionUpdateManyDataInput;
}

export interface SessionUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  duration?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface SessionTypeUpsertWithWhereUniqueWithoutCoachInput {
  where: SessionTypeWhereUniqueInput;
  update: SessionTypeUpdateWithoutCoachDataInput;
  create: SessionTypeCreateWithoutCoachInput;
}

export interface SessionTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  maxSeats_not?: Maybe<Int>;
  maxSeats_in?: Maybe<Int[] | Int>;
  maxSeats_not_in?: Maybe<Int[] | Int>;
  maxSeats_lt?: Maybe<Int>;
  maxSeats_lte?: Maybe<Int>;
  maxSeats_gt?: Maybe<Int>;
  maxSeats_gte?: Maybe<Int>;
  cost?: Maybe<Int>;
  cost_not?: Maybe<Int>;
  cost_in?: Maybe<Int[] | Int>;
  cost_not_in?: Maybe<Int[] | Int>;
  cost_lt?: Maybe<Int>;
  cost_lte?: Maybe<Int>;
  cost_gt?: Maybe<Int>;
  cost_gte?: Maybe<Int>;
  AND?: Maybe<SessionTypeScalarWhereInput[] | SessionTypeScalarWhereInput>;
  OR?: Maybe<SessionTypeScalarWhereInput[] | SessionTypeScalarWhereInput>;
  NOT?: Maybe<SessionTypeScalarWhereInput[] | SessionTypeScalarWhereInput>;
}

export interface SessionTypeUpdateManyWithWhereNestedInput {
  where: SessionTypeScalarWhereInput;
  data: SessionTypeUpdateManyDataInput;
}

export interface SessionTypeUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface CustomerUpdateManyWithoutCoachInput {
  create?: Maybe<
    CustomerCreateWithoutCoachInput[] | CustomerCreateWithoutCoachInput
  >;
  delete?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  connect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  set?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  disconnect?: Maybe<CustomerWhereUniqueInput[] | CustomerWhereUniqueInput>;
  update?: Maybe<
    | CustomerUpdateWithWhereUniqueWithoutCoachInput[]
    | CustomerUpdateWithWhereUniqueWithoutCoachInput
  >;
  upsert?: Maybe<
    | CustomerUpsertWithWhereUniqueWithoutCoachInput[]
    | CustomerUpsertWithWhereUniqueWithoutCoachInput
  >;
  deleteMany?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  updateMany?: Maybe<
    | CustomerUpdateManyWithWhereNestedInput[]
    | CustomerUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerUpdateWithWhereUniqueWithoutCoachInput {
  where: CustomerWhereUniqueInput;
  data: CustomerUpdateWithoutCoachDataInput;
}

export interface CustomerUpdateWithoutCoachDataInput {
  role?: Maybe<Role>;
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
}

export interface CustomerUpsertWithWhereUniqueWithoutCoachInput {
  where: CustomerWhereUniqueInput;
  update: CustomerUpdateWithoutCoachDataInput;
  create: CustomerCreateWithoutCoachInput;
}

export interface CustomerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailToken_not?: Maybe<String>;
  emailToken_in?: Maybe<String[] | String>;
  emailToken_not_in?: Maybe<String[] | String>;
  emailToken_lt?: Maybe<String>;
  emailToken_lte?: Maybe<String>;
  emailToken_gt?: Maybe<String>;
  emailToken_gte?: Maybe<String>;
  emailToken_contains?: Maybe<String>;
  emailToken_not_contains?: Maybe<String>;
  emailToken_starts_with?: Maybe<String>;
  emailToken_not_starts_with?: Maybe<String>;
  emailToken_ends_with?: Maybe<String>;
  emailToken_not_ends_with?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  emailTokenExpiry_not?: Maybe<Float>;
  emailTokenExpiry_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_lt?: Maybe<Float>;
  emailTokenExpiry_lte?: Maybe<Float>;
  emailTokenExpiry_gt?: Maybe<Float>;
  emailTokenExpiry_gte?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteToken_not?: Maybe<String>;
  inviteToken_in?: Maybe<String[] | String>;
  inviteToken_not_in?: Maybe<String[] | String>;
  inviteToken_lt?: Maybe<String>;
  inviteToken_lte?: Maybe<String>;
  inviteToken_gt?: Maybe<String>;
  inviteToken_gte?: Maybe<String>;
  inviteToken_contains?: Maybe<String>;
  inviteToken_not_contains?: Maybe<String>;
  inviteToken_starts_with?: Maybe<String>;
  inviteToken_not_starts_with?: Maybe<String>;
  inviteToken_ends_with?: Maybe<String>;
  inviteToken_not_ends_with?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  inviteTokenExpiry_not?: Maybe<Float>;
  inviteTokenExpiry_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_not_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_lt?: Maybe<Float>;
  inviteTokenExpiry_lte?: Maybe<Float>;
  inviteTokenExpiry_gt?: Maybe<Float>;
  inviteTokenExpiry_gte?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  OR?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
  NOT?: Maybe<CustomerScalarWhereInput[] | CustomerScalarWhereInput>;
}

export interface CustomerUpdateManyWithWhereNestedInput {
  where: CustomerScalarWhereInput;
  data: CustomerUpdateManyDataInput;
}

export interface CustomerUpdateManyDataInput {
  role?: Maybe<Role>;
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailToken_not?: Maybe<String>;
  emailToken_in?: Maybe<String[] | String>;
  emailToken_not_in?: Maybe<String[] | String>;
  emailToken_lt?: Maybe<String>;
  emailToken_lte?: Maybe<String>;
  emailToken_gt?: Maybe<String>;
  emailToken_gte?: Maybe<String>;
  emailToken_contains?: Maybe<String>;
  emailToken_not_contains?: Maybe<String>;
  emailToken_starts_with?: Maybe<String>;
  emailToken_not_starts_with?: Maybe<String>;
  emailToken_ends_with?: Maybe<String>;
  emailToken_not_ends_with?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  emailTokenExpiry_not?: Maybe<Float>;
  emailTokenExpiry_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailTokenExpiry_lt?: Maybe<Float>;
  emailTokenExpiry_lte?: Maybe<Float>;
  emailTokenExpiry_gt?: Maybe<Float>;
  emailTokenExpiry_gte?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteToken_not?: Maybe<String>;
  inviteToken_in?: Maybe<String[] | String>;
  inviteToken_not_in?: Maybe<String[] | String>;
  inviteToken_lt?: Maybe<String>;
  inviteToken_lte?: Maybe<String>;
  inviteToken_gt?: Maybe<String>;
  inviteToken_gte?: Maybe<String>;
  inviteToken_contains?: Maybe<String>;
  inviteToken_not_contains?: Maybe<String>;
  inviteToken_starts_with?: Maybe<String>;
  inviteToken_not_starts_with?: Maybe<String>;
  inviteToken_ends_with?: Maybe<String>;
  inviteToken_not_ends_with?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  inviteTokenExpiry_not?: Maybe<Float>;
  inviteTokenExpiry_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_not_in?: Maybe<Float[] | Float>;
  inviteTokenExpiry_lt?: Maybe<Float>;
  inviteTokenExpiry_lte?: Maybe<Float>;
  inviteTokenExpiry_gt?: Maybe<Float>;
  inviteTokenExpiry_gte?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  timezone?: Maybe<String>;
  timezone_not?: Maybe<String>;
  timezone_in?: Maybe<String[] | String>;
  timezone_not_in?: Maybe<String[] | String>;
  timezone_lt?: Maybe<String>;
  timezone_lte?: Maybe<String>;
  timezone_gt?: Maybe<String>;
  timezone_gte?: Maybe<String>;
  timezone_contains?: Maybe<String>;
  timezone_not_contains?: Maybe<String>;
  timezone_starts_with?: Maybe<String>;
  timezone_not_starts_with?: Maybe<String>;
  timezone_ends_with?: Maybe<String>;
  timezone_not_ends_with?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  backgroundColor_not?: Maybe<String>;
  backgroundColor_in?: Maybe<String[] | String>;
  backgroundColor_not_in?: Maybe<String[] | String>;
  backgroundColor_lt?: Maybe<String>;
  backgroundColor_lte?: Maybe<String>;
  backgroundColor_gt?: Maybe<String>;
  backgroundColor_gte?: Maybe<String>;
  backgroundColor_contains?: Maybe<String>;
  backgroundColor_not_contains?: Maybe<String>;
  backgroundColor_starts_with?: Maybe<String>;
  backgroundColor_not_starts_with?: Maybe<String>;
  backgroundColor_ends_with?: Maybe<String>;
  backgroundColor_not_ends_with?: Maybe<String>;
  biography?: Maybe<String>;
  biography_not?: Maybe<String>;
  biography_in?: Maybe<String[] | String>;
  biography_not_in?: Maybe<String[] | String>;
  biography_lt?: Maybe<String>;
  biography_lte?: Maybe<String>;
  biography_gt?: Maybe<String>;
  biography_gte?: Maybe<String>;
  biography_contains?: Maybe<String>;
  biography_not_contains?: Maybe<String>;
  biography_starts_with?: Maybe<String>;
  biography_not_starts_with?: Maybe<String>;
  biography_ends_with?: Maybe<String>;
  biography_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  twitter?: Maybe<String>;
  twitter_not?: Maybe<String>;
  twitter_in?: Maybe<String[] | String>;
  twitter_not_in?: Maybe<String[] | String>;
  twitter_lt?: Maybe<String>;
  twitter_lte?: Maybe<String>;
  twitter_gt?: Maybe<String>;
  twitter_gte?: Maybe<String>;
  twitter_contains?: Maybe<String>;
  twitter_not_contains?: Maybe<String>;
  twitter_starts_with?: Maybe<String>;
  twitter_not_starts_with?: Maybe<String>;
  twitter_ends_with?: Maybe<String>;
  twitter_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface UserUpsertWithoutActivitiesInput {
  update: UserUpdateWithoutActivitiesDataInput;
  create: UserCreateWithoutActivitiesInput;
}

export interface AvailabilityUpdateInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface AvailabilityUpdateManyMutationInput {
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface BookingCreateInput {
  id?: Maybe<ID_Input>;
  customer?: Maybe<CustomerCreateOneInput>;
  session: SessionCreateOneWithoutBookingsInput;
  timeSlot?: Maybe<String>;
  charge?: Maybe<ChargeCreateOneInput>;
}

export interface SessionCreateOneWithoutBookingsInput {
  create?: Maybe<SessionCreateWithoutBookingsInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionCreateWithoutBookingsInput {
  id?: Maybe<ID_Input>;
  coach?: Maybe<UserCreateOneInput>;
  sessionType?: Maybe<SessionTypeCreateOneWithoutSessionsInput>;
  name: String;
  description?: Maybe<String>;
  location: String;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability: AvailabilityCreateOneInput;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourCreateOneInput>;
  duration: Int;
  coverImage?: Maybe<ImageCreateOneInput>;
  cost?: Maybe<Int>;
}

export interface SessionTypeCreateOneWithoutSessionsInput {
  create?: Maybe<SessionTypeCreateWithoutSessionsInput>;
  connect?: Maybe<SessionTypeWhereUniqueInput>;
}

export interface SessionTypeCreateWithoutSessionsInput {
  id?: Maybe<ID_Input>;
  coach?: Maybe<UserCreateOneWithoutSessionTypesInput>;
  name: String;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost: Int;
}

export interface UserCreateOneWithoutSessionTypesInput {
  create?: Maybe<UserCreateWithoutSessionTypesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutSessionTypesInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserCreateManyInput>;
  lastLogin?: Maybe<LastLoginCreateOneInput>;
  name: String;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageCreateOneInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  stripeAccount?: Maybe<StripeAccountCreateOneInput>;
  activities?: Maybe<ActivityCreateManyWithoutUserInput>;
  customers?: Maybe<CustomerCreateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface BookingUpdateInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutBookingsInput>;
  timeSlot?: Maybe<String>;
  charge?: Maybe<ChargeUpdateOneInput>;
}

export interface SessionUpdateOneRequiredWithoutBookingsInput {
  create?: Maybe<SessionCreateWithoutBookingsInput>;
  update?: Maybe<SessionUpdateWithoutBookingsDataInput>;
  upsert?: Maybe<SessionUpsertWithoutBookingsInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionUpdateWithoutBookingsDataInput {
  coach?: Maybe<UserUpdateOneInput>;
  sessionType?: Maybe<SessionTypeUpdateOneWithoutSessionsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability?: Maybe<AvailabilityUpdateOneRequiredInput>;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourUpdateOneInput>;
  duration?: Maybe<Int>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  cost?: Maybe<Int>;
}

export interface SessionTypeUpdateOneWithoutSessionsInput {
  create?: Maybe<SessionTypeCreateWithoutSessionsInput>;
  update?: Maybe<SessionTypeUpdateWithoutSessionsDataInput>;
  upsert?: Maybe<SessionTypeUpsertWithoutSessionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SessionTypeWhereUniqueInput>;
}

export interface SessionTypeUpdateWithoutSessionsDataInput {
  coach?: Maybe<UserUpdateOneWithoutSessionTypesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface UserUpdateOneWithoutSessionTypesInput {
  create?: Maybe<UserCreateWithoutSessionTypesInput>;
  update?: Maybe<UserUpdateWithoutSessionTypesDataInput>;
  upsert?: Maybe<UserUpsertWithoutSessionTypesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutSessionTypesDataInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserUpdateManyInput>;
  lastLogin?: Maybe<LastLoginUpdateOneInput>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
  activities?: Maybe<ActivityUpdateManyWithoutUserInput>;
  customers?: Maybe<CustomerUpdateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface UserUpsertWithoutSessionTypesInput {
  update: UserUpdateWithoutSessionTypesDataInput;
  create: UserCreateWithoutSessionTypesInput;
}

export interface SessionTypeUpsertWithoutSessionsInput {
  update: SessionTypeUpdateWithoutSessionsDataInput;
  create: SessionTypeCreateWithoutSessionsInput;
}

export interface SessionUpsertWithoutBookingsInput {
  update: SessionUpdateWithoutBookingsDataInput;
  create: SessionCreateWithoutBookingsInput;
}

export interface BookingUpdateManyMutationInput {
  timeSlot?: Maybe<String>;
}

export interface BusinessHourUpdateInput {
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface BusinessHourUpdateManyMutationInput {
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface ChargeUpdateInput {
  coach?: Maybe<UserUpdateOneRequiredInput>;
  id?: Maybe<String>;
  stripe_user_id?: Maybe<String>;
  amount?: Maybe<Float>;
  amount_refunded?: Maybe<Float>;
  application_fee_amount?: Maybe<Float>;
  description?: Maybe<String>;
  receipt_url?: Maybe<String>;
  refunded?: Maybe<Boolean>;
  currency?: Maybe<String>;
}

export interface ChargeUpdateManyMutationInput {
  id?: Maybe<String>;
  stripe_user_id?: Maybe<String>;
  amount?: Maybe<Float>;
  amount_refunded?: Maybe<Float>;
  application_fee_amount?: Maybe<Float>;
  description?: Maybe<String>;
  receipt_url?: Maybe<String>;
  refunded?: Maybe<Boolean>;
  currency?: Maybe<String>;
}

export interface ContentUpdateInput {
  type?: Maybe<String>;
  message?: Maybe<String>;
}

export interface ContentUpdateManyMutationInput {
  type?: Maybe<String>;
  message?: Maybe<String>;
}

export interface CustomerUpdateInput {
  coach?: Maybe<UserUpdateOneRequiredWithoutCustomersInput>;
  role?: Maybe<Role>;
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
}

export interface CustomerUpdateManyMutationInput {
  role?: Maybe<Role>;
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
}

export interface ImageUpdateInput {
  url?: Maybe<String>;
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface ImageUpdateManyMutationInput {
  url?: Maybe<String>;
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface LastLoginUpdateInput {
  action?: Maybe<String>;
}

export interface LastLoginUpdateManyMutationInput {
  action?: Maybe<String>;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  coach?: Maybe<UserCreateOneInput>;
  sessionType?: Maybe<SessionTypeCreateOneWithoutSessionsInput>;
  name: String;
  description?: Maybe<String>;
  location: String;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability: AvailabilityCreateOneInput;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourCreateOneInput>;
  duration: Int;
  bookings?: Maybe<BookingCreateManyWithoutSessionInput>;
  coverImage?: Maybe<ImageCreateOneInput>;
  cost?: Maybe<Int>;
}

export interface SessionUpdateInput {
  coach?: Maybe<UserUpdateOneInput>;
  sessionType?: Maybe<SessionTypeUpdateOneWithoutSessionsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  availability?: Maybe<AvailabilityUpdateOneRequiredInput>;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  businessHour?: Maybe<BusinessHourUpdateOneInput>;
  duration?: Maybe<Int>;
  bookings?: Maybe<BookingUpdateManyWithoutSessionInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  cost?: Maybe<Int>;
}

export interface SessionUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  link?: Maybe<String>;
  recurring?: Maybe<Boolean>;
  maxSeats?: Maybe<Int>;
  singleEvent?: Maybe<Boolean>;
  duration?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface SessionTypeCreateInput {
  id?: Maybe<ID_Input>;
  coach?: Maybe<UserCreateOneWithoutSessionTypesInput>;
  name: String;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost: Int;
  sessions?: Maybe<SessionCreateManyWithoutSessionTypeInput>;
}

export interface SessionTypeUpdateInput {
  coach?: Maybe<UserUpdateOneWithoutSessionTypesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost?: Maybe<Int>;
  sessions?: Maybe<SessionUpdateManyWithoutSessionTypeInput>;
}

export interface SessionTypeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  maxSeats?: Maybe<Int>;
  cost?: Maybe<Int>;
}

export interface StripeAccountUpdateInput {
  stripe_user_id?: Maybe<String>;
  access_token?: Maybe<String>;
  scope?: Maybe<String>;
  livemode?: Maybe<Boolean>;
  token_type?: Maybe<String>;
  refresh_token?: Maybe<String>;
  stripe_publishable_key?: Maybe<String>;
}

export interface StripeAccountUpdateManyMutationInput {
  stripe_user_id?: Maybe<String>;
  access_token?: Maybe<String>;
  scope?: Maybe<String>;
  livemode?: Maybe<Boolean>;
  token_type?: Maybe<String>;
  refresh_token?: Maybe<String>;
  stripe_publishable_key?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  coaches?: Maybe<UserUpdateManyInput>;
  sessionTypes?: Maybe<SessionTypeUpdateManyWithoutCoachInput>;
  lastLogin?: Maybe<LastLoginUpdateOneInput>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  profileImage?: Maybe<ImageUpdateOneInput>;
  coverImage?: Maybe<ImageUpdateOneInput>;
  stripeAccount?: Maybe<StripeAccountUpdateOneInput>;
  activities?: Maybe<ActivityUpdateManyWithoutUserInput>;
  customers?: Maybe<CustomerUpdateManyWithoutCoachInput>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  emailToken?: Maybe<String>;
  emailTokenExpiry?: Maybe<Float>;
  inviteToken?: Maybe<String>;
  inviteTokenExpiry?: Maybe<Float>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  verified?: Maybe<Boolean>;
  role?: Maybe<Role>;
  name?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  timezone?: Maybe<String>;
  backgroundColor?: Maybe<String>;
  biography?: Maybe<String>;
  facebook?: Maybe<String>;
  twitter?: Maybe<String>;
  website?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface ActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActivityWhereInput>;
  AND?: Maybe<
    ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput
  >;
}

export interface AvailabilitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AvailabilityWhereInput>;
  AND?: Maybe<
    AvailabilitySubscriptionWhereInput[] | AvailabilitySubscriptionWhereInput
  >;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookingWhereInput>;
  AND?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
}

export interface BusinessHourSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BusinessHourWhereInput>;
  AND?: Maybe<
    BusinessHourSubscriptionWhereInput[] | BusinessHourSubscriptionWhereInput
  >;
}

export interface ChargeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChargeWhereInput>;
  AND?: Maybe<ChargeSubscriptionWhereInput[] | ChargeSubscriptionWhereInput>;
}

export interface ContentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContentWhereInput>;
  AND?: Maybe<ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface LastLoginSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LastLoginWhereInput>;
  AND?: Maybe<
    LastLoginSubscriptionWhereInput[] | LastLoginSubscriptionWhereInput
  >;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface SessionTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionTypeWhereInput>;
  AND?: Maybe<
    SessionTypeSubscriptionWhereInput[] | SessionTypeSubscriptionWhereInput
  >;
}

export interface StripeAccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StripeAccountWhereInput>;
  AND?: Maybe<
    StripeAccountSubscriptionWhereInput[] | StripeAccountSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Activity {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ActivityPromise extends Promise<Activity>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  content: <T = ContentPromise>() => T;
}

export interface ActivitySubscription
  extends Promise<AsyncIterator<Activity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: <T = ContentSubscription>() => T;
}

export interface ActivityNullablePromise
  extends Promise<Activity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  content: <T = ContentPromise>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  emailToken?: String;
  emailTokenExpiry?: Float;
  inviteToken?: String;
  inviteTokenExpiry?: Float;
  resetToken?: String;
  resetTokenExpiry?: Float;
  verified: Boolean;
  role: Role;
  name: String;
  username?: String;
  password?: String;
  timezone?: String;
  backgroundColor?: String;
  biography?: String;
  facebook?: String;
  twitter?: String;
  website?: String;
  mobile?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  role: () => Promise<Role>;
  coaches: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessionTypes: <T = FragmentableArray<SessionType>>(args?: {
    where?: SessionTypeWhereInput;
    orderBy?: SessionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastLogin: <T = LastLoginPromise>() => T;
  name: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  timezone: () => Promise<String>;
  backgroundColor: () => Promise<String>;
  profileImage: <T = ImagePromise>() => T;
  coverImage: <T = ImagePromise>() => T;
  stripeAccount: <T = StripeAccountPromise>() => T;
  activities: <T = FragmentableArray<Activity>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  biography: () => Promise<String>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  website: () => Promise<String>;
  mobile: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  emailToken: () => Promise<AsyncIterator<String>>;
  emailTokenExpiry: () => Promise<AsyncIterator<Float>>;
  inviteToken: () => Promise<AsyncIterator<String>>;
  inviteTokenExpiry: () => Promise<AsyncIterator<Float>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<Role>>;
  coaches: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessionTypes: <T = Promise<AsyncIterator<SessionTypeSubscription>>>(args?: {
    where?: SessionTypeWhereInput;
    orderBy?: SessionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastLogin: <T = LastLoginSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  timezone: () => Promise<AsyncIterator<String>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  profileImage: <T = ImageSubscription>() => T;
  coverImage: <T = ImageSubscription>() => T;
  stripeAccount: <T = StripeAccountSubscription>() => T;
  activities: <T = Promise<AsyncIterator<ActivitySubscription>>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = Promise<AsyncIterator<CustomerSubscription>>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  biography: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  role: () => Promise<Role>;
  coaches: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sessionTypes: <T = FragmentableArray<SessionType>>(args?: {
    where?: SessionTypeWhereInput;
    orderBy?: SessionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastLogin: <T = LastLoginPromise>() => T;
  name: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  timezone: () => Promise<String>;
  backgroundColor: () => Promise<String>;
  profileImage: <T = ImagePromise>() => T;
  coverImage: <T = ImagePromise>() => T;
  stripeAccount: <T = StripeAccountPromise>() => T;
  activities: <T = FragmentableArray<Activity>>(args?: {
    where?: ActivityWhereInput;
    orderBy?: ActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = FragmentableArray<Customer>>(args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  biography: () => Promise<String>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  website: () => Promise<String>;
  mobile: () => Promise<String>;
}

export interface SessionType {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  duration: Int;
  maxSeats: Int;
  cost: Int;
}

export interface SessionTypePromise extends Promise<SessionType>, Fragmentable {
  id: () => Promise<ID_Output>;
  coach: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  maxSeats: () => Promise<Int>;
  cost: () => Promise<Int>;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SessionTypeSubscription
  extends Promise<AsyncIterator<SessionType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  coach: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  maxSeats: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SessionTypeNullablePromise
  extends Promise<SessionType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  coach: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  maxSeats: () => Promise<Int>;
  cost: () => Promise<Int>;
  sessions: <T = FragmentableArray<Session>>(args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Session {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  location: String;
  link?: String;
  recurring?: Boolean;
  maxSeats: Int;
  singleEvent?: Boolean;
  duration: Int;
  cost?: Int;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  coach: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sessionType: <T = SessionTypePromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  link: () => Promise<String>;
  recurring: () => Promise<Boolean>;
  availability: <T = AvailabilityPromise>() => T;
  maxSeats: () => Promise<Int>;
  singleEvent: () => Promise<Boolean>;
  businessHour: <T = BusinessHourPromise>() => T;
  duration: () => Promise<Int>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  coverImage: <T = ImagePromise>() => T;
  cost: () => Promise<Int>;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  coach: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sessionType: <T = SessionTypeSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  recurring: () => Promise<AsyncIterator<Boolean>>;
  availability: <T = AvailabilitySubscription>() => T;
  maxSeats: () => Promise<AsyncIterator<Int>>;
  singleEvent: () => Promise<AsyncIterator<Boolean>>;
  businessHour: <T = BusinessHourSubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  coverImage: <T = ImageSubscription>() => T;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  coach: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sessionType: <T = SessionTypePromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  link: () => Promise<String>;
  recurring: () => Promise<Boolean>;
  availability: <T = AvailabilityPromise>() => T;
  maxSeats: () => Promise<Int>;
  singleEvent: () => Promise<Boolean>;
  businessHour: <T = BusinessHourPromise>() => T;
  duration: () => Promise<Int>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  coverImage: <T = ImagePromise>() => T;
  cost: () => Promise<Int>;
}

export interface Availability {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
}

export interface AvailabilityPromise
  extends Promise<Availability>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface AvailabilitySubscription
  extends Promise<AsyncIterator<Availability>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AvailabilityNullablePromise
  extends Promise<Availability | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface BusinessHour {
  id: ID_Output;
  start?: String;
  end?: String;
}

export interface BusinessHourPromise
  extends Promise<BusinessHour>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface BusinessHourSubscription
  extends Promise<AsyncIterator<BusinessHour>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<String>>;
  end: () => Promise<AsyncIterator<String>>;
}

export interface BusinessHourNullablePromise
  extends Promise<BusinessHour | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface Booking {
  id: ID_Output;
  timeSlot?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  session: <T = SessionPromise>() => T;
  timeSlot: () => Promise<String>;
  charge: <T = ChargePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  session: <T = SessionSubscription>() => T;
  timeSlot: () => Promise<AsyncIterator<String>>;
  charge: <T = ChargeSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookingNullablePromise
  extends Promise<Booking | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  session: <T = SessionPromise>() => T;
  timeSlot: () => Promise<String>;
  charge: <T = ChargePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Customer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: Role;
  email: String;
  emailToken?: String;
  emailTokenExpiry?: Float;
  inviteToken?: String;
  inviteTokenExpiry?: Float;
  resetToken?: String;
  resetTokenExpiry?: Float;
  verified: Boolean;
  name: String;
  password?: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  coach: <T = UserPromise>() => T;
  role: () => Promise<Role>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  profileImage: <T = ImagePromise>() => T;
  coverImage: <T = ImagePromise>() => T;
  stripeAccount: <T = StripeAccountPromise>() => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  coach: <T = UserSubscription>() => T;
  role: () => Promise<AsyncIterator<Role>>;
  email: () => Promise<AsyncIterator<String>>;
  emailToken: () => Promise<AsyncIterator<String>>;
  emailTokenExpiry: () => Promise<AsyncIterator<Float>>;
  inviteToken: () => Promise<AsyncIterator<String>>;
  inviteTokenExpiry: () => Promise<AsyncIterator<Float>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profileImage: <T = ImageSubscription>() => T;
  coverImage: <T = ImageSubscription>() => T;
  stripeAccount: <T = StripeAccountSubscription>() => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  coach: <T = UserPromise>() => T;
  role: () => Promise<Role>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  profileImage: <T = ImagePromise>() => T;
  coverImage: <T = ImagePromise>() => T;
  stripeAccount: <T = StripeAccountPromise>() => T;
}

export interface Image {
  id: ID_Output;
  url: String;
  width: Int;
  height: Int;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface StripeAccount {
  id: ID_Output;
  stripe_user_id: String;
  access_token: String;
  scope: String;
  livemode: Boolean;
  token_type: String;
  refresh_token: String;
  stripe_publishable_key: String;
}

export interface StripeAccountPromise
  extends Promise<StripeAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stripe_user_id: () => Promise<String>;
  access_token: () => Promise<String>;
  scope: () => Promise<String>;
  livemode: () => Promise<Boolean>;
  token_type: () => Promise<String>;
  refresh_token: () => Promise<String>;
  stripe_publishable_key: () => Promise<String>;
}

export interface StripeAccountSubscription
  extends Promise<AsyncIterator<StripeAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  access_token: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
  livemode: () => Promise<AsyncIterator<Boolean>>;
  token_type: () => Promise<AsyncIterator<String>>;
  refresh_token: () => Promise<AsyncIterator<String>>;
  stripe_publishable_key: () => Promise<AsyncIterator<String>>;
}

export interface StripeAccountNullablePromise
  extends Promise<StripeAccount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stripe_user_id: () => Promise<String>;
  access_token: () => Promise<String>;
  scope: () => Promise<String>;
  livemode: () => Promise<Boolean>;
  token_type: () => Promise<String>;
  refresh_token: () => Promise<String>;
  stripe_publishable_key: () => Promise<String>;
}

export interface Charge {
  _id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: String;
  stripe_user_id: String;
  amount: Float;
  amount_refunded: Float;
  application_fee_amount?: Float;
  description?: String;
  receipt_url: String;
  refunded: Boolean;
  currency: String;
}

export interface ChargePromise extends Promise<Charge>, Fragmentable {
  _id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  coach: <T = UserPromise>() => T;
  id: () => Promise<String>;
  stripe_user_id: () => Promise<String>;
  amount: () => Promise<Float>;
  amount_refunded: () => Promise<Float>;
  application_fee_amount: () => Promise<Float>;
  description: () => Promise<String>;
  receipt_url: () => Promise<String>;
  refunded: () => Promise<Boolean>;
  currency: () => Promise<String>;
}

export interface ChargeSubscription
  extends Promise<AsyncIterator<Charge>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  coach: <T = UserSubscription>() => T;
  id: () => Promise<AsyncIterator<String>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Float>>;
  amount_refunded: () => Promise<AsyncIterator<Float>>;
  application_fee_amount: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  receipt_url: () => Promise<AsyncIterator<String>>;
  refunded: () => Promise<AsyncIterator<Boolean>>;
  currency: () => Promise<AsyncIterator<String>>;
}

export interface ChargeNullablePromise
  extends Promise<Charge | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  coach: <T = UserPromise>() => T;
  id: () => Promise<String>;
  stripe_user_id: () => Promise<String>;
  amount: () => Promise<Float>;
  amount_refunded: () => Promise<Float>;
  application_fee_amount: () => Promise<Float>;
  description: () => Promise<String>;
  receipt_url: () => Promise<String>;
  refunded: () => Promise<Boolean>;
  currency: () => Promise<String>;
}

export interface LastLogin {
  id: ID_Output;
  date: DateTimeOutput;
  action: String;
}

export interface LastLoginPromise extends Promise<LastLogin>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
}

export interface LastLoginSubscription
  extends Promise<AsyncIterator<LastLogin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
}

export interface LastLoginNullablePromise
  extends Promise<LastLogin | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
}

export interface Content {
  id: ID_Output;
  type?: String;
  message?: String;
}

export interface ContentPromise extends Promise<Content>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  message: () => Promise<String>;
}

export interface ContentSubscription
  extends Promise<AsyncIterator<Content>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface ContentNullablePromise
  extends Promise<Content | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  message: () => Promise<String>;
}

export interface ActivityConnection {
  pageInfo: PageInfo;
  edges: ActivityEdge[];
}

export interface ActivityConnectionPromise
  extends Promise<ActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivityEdge>>() => T;
  aggregate: <T = AggregateActivityPromise>() => T;
}

export interface ActivityConnectionSubscription
  extends Promise<AsyncIterator<ActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivitySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityEdge {
  node: Activity;
  cursor: String;
}

export interface ActivityEdgePromise
  extends Promise<ActivityEdge>,
    Fragmentable {
  node: <T = ActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityEdgeSubscription
  extends Promise<AsyncIterator<ActivityEdge>>,
    Fragmentable {
  node: <T = ActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivity {
  count: Int;
}

export interface AggregateActivityPromise
  extends Promise<AggregateActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivitySubscription
  extends Promise<AsyncIterator<AggregateActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvailabilityConnection {
  pageInfo: PageInfo;
  edges: AvailabilityEdge[];
}

export interface AvailabilityConnectionPromise
  extends Promise<AvailabilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvailabilityEdge>>() => T;
  aggregate: <T = AggregateAvailabilityPromise>() => T;
}

export interface AvailabilityConnectionSubscription
  extends Promise<AsyncIterator<AvailabilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvailabilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvailabilitySubscription>() => T;
}

export interface AvailabilityEdge {
  node: Availability;
  cursor: String;
}

export interface AvailabilityEdgePromise
  extends Promise<AvailabilityEdge>,
    Fragmentable {
  node: <T = AvailabilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvailabilityEdgeSubscription
  extends Promise<AsyncIterator<AvailabilityEdge>>,
    Fragmentable {
  node: <T = AvailabilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvailability {
  count: Int;
}

export interface AggregateAvailabilityPromise
  extends Promise<AggregateAvailability>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvailabilitySubscription
  extends Promise<AsyncIterator<AggregateAvailability>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BusinessHourConnection {
  pageInfo: PageInfo;
  edges: BusinessHourEdge[];
}

export interface BusinessHourConnectionPromise
  extends Promise<BusinessHourConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BusinessHourEdge>>() => T;
  aggregate: <T = AggregateBusinessHourPromise>() => T;
}

export interface BusinessHourConnectionSubscription
  extends Promise<AsyncIterator<BusinessHourConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BusinessHourEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBusinessHourSubscription>() => T;
}

export interface BusinessHourEdge {
  node: BusinessHour;
  cursor: String;
}

export interface BusinessHourEdgePromise
  extends Promise<BusinessHourEdge>,
    Fragmentable {
  node: <T = BusinessHourPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BusinessHourEdgeSubscription
  extends Promise<AsyncIterator<BusinessHourEdge>>,
    Fragmentable {
  node: <T = BusinessHourSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBusinessHour {
  count: Int;
}

export interface AggregateBusinessHourPromise
  extends Promise<AggregateBusinessHour>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBusinessHourSubscription
  extends Promise<AsyncIterator<AggregateBusinessHour>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChargeConnection {
  pageInfo: PageInfo;
  edges: ChargeEdge[];
}

export interface ChargeConnectionPromise
  extends Promise<ChargeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChargeEdge>>() => T;
  aggregate: <T = AggregateChargePromise>() => T;
}

export interface ChargeConnectionSubscription
  extends Promise<AsyncIterator<ChargeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChargeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChargeSubscription>() => T;
}

export interface ChargeEdge {
  node: Charge;
  cursor: String;
}

export interface ChargeEdgePromise extends Promise<ChargeEdge>, Fragmentable {
  node: <T = ChargePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChargeEdgeSubscription
  extends Promise<AsyncIterator<ChargeEdge>>,
    Fragmentable {
  node: <T = ChargeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharge {
  count: Int;
}

export interface AggregateChargePromise
  extends Promise<AggregateCharge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChargeSubscription
  extends Promise<AsyncIterator<AggregateCharge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContentConnection {
  pageInfo: PageInfo;
  edges: ContentEdge[];
}

export interface ContentConnectionPromise
  extends Promise<ContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentEdge>>() => T;
  aggregate: <T = AggregateContentPromise>() => T;
}

export interface ContentConnectionSubscription
  extends Promise<AsyncIterator<ContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentSubscription>() => T;
}

export interface ContentEdge {
  node: Content;
  cursor: String;
}

export interface ContentEdgePromise extends Promise<ContentEdge>, Fragmentable {
  node: <T = ContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentEdgeSubscription
  extends Promise<AsyncIterator<ContentEdge>>,
    Fragmentable {
  node: <T = ContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContent {
  count: Int;
}

export interface AggregateContentPromise
  extends Promise<AggregateContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentSubscription
  extends Promise<AsyncIterator<AggregateContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LastLoginConnection {
  pageInfo: PageInfo;
  edges: LastLoginEdge[];
}

export interface LastLoginConnectionPromise
  extends Promise<LastLoginConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LastLoginEdge>>() => T;
  aggregate: <T = AggregateLastLoginPromise>() => T;
}

export interface LastLoginConnectionSubscription
  extends Promise<AsyncIterator<LastLoginConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LastLoginEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLastLoginSubscription>() => T;
}

export interface LastLoginEdge {
  node: LastLogin;
  cursor: String;
}

export interface LastLoginEdgePromise
  extends Promise<LastLoginEdge>,
    Fragmentable {
  node: <T = LastLoginPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LastLoginEdgeSubscription
  extends Promise<AsyncIterator<LastLoginEdge>>,
    Fragmentable {
  node: <T = LastLoginSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLastLogin {
  count: Int;
}

export interface AggregateLastLoginPromise
  extends Promise<AggregateLastLogin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLastLoginSubscription
  extends Promise<AsyncIterator<AggregateLastLogin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionTypeConnection {
  pageInfo: PageInfo;
  edges: SessionTypeEdge[];
}

export interface SessionTypeConnectionPromise
  extends Promise<SessionTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionTypeEdge>>() => T;
  aggregate: <T = AggregateSessionTypePromise>() => T;
}

export interface SessionTypeConnectionSubscription
  extends Promise<AsyncIterator<SessionTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionTypeSubscription>() => T;
}

export interface SessionTypeEdge {
  node: SessionType;
  cursor: String;
}

export interface SessionTypeEdgePromise
  extends Promise<SessionTypeEdge>,
    Fragmentable {
  node: <T = SessionTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionTypeEdgeSubscription
  extends Promise<AsyncIterator<SessionTypeEdge>>,
    Fragmentable {
  node: <T = SessionTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSessionType {
  count: Int;
}

export interface AggregateSessionTypePromise
  extends Promise<AggregateSessionType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionTypeSubscription
  extends Promise<AsyncIterator<AggregateSessionType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StripeAccountConnection {
  pageInfo: PageInfo;
  edges: StripeAccountEdge[];
}

export interface StripeAccountConnectionPromise
  extends Promise<StripeAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StripeAccountEdge>>() => T;
  aggregate: <T = AggregateStripeAccountPromise>() => T;
}

export interface StripeAccountConnectionSubscription
  extends Promise<AsyncIterator<StripeAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StripeAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStripeAccountSubscription>() => T;
}

export interface StripeAccountEdge {
  node: StripeAccount;
  cursor: String;
}

export interface StripeAccountEdgePromise
  extends Promise<StripeAccountEdge>,
    Fragmentable {
  node: <T = StripeAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StripeAccountEdgeSubscription
  extends Promise<AsyncIterator<StripeAccountEdge>>,
    Fragmentable {
  node: <T = StripeAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStripeAccount {
  count: Int;
}

export interface AggregateStripeAccountPromise
  extends Promise<AggregateStripeAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStripeAccountSubscription
  extends Promise<AsyncIterator<AggregateStripeAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivitySubscriptionPayload {
  mutation: MutationType;
  node: Activity;
  updatedFields: String[];
  previousValues: ActivityPreviousValues;
}

export interface ActivitySubscriptionPayloadPromise
  extends Promise<ActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityPreviousValuesPromise>() => T;
}

export interface ActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityPreviousValuesSubscription>() => T;
}

export interface ActivityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface ActivityPreviousValuesPromise
  extends Promise<ActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AvailabilitySubscriptionPayload {
  mutation: MutationType;
  node: Availability;
  updatedFields: String[];
  previousValues: AvailabilityPreviousValues;
}

export interface AvailabilitySubscriptionPayloadPromise
  extends Promise<AvailabilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvailabilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvailabilityPreviousValuesPromise>() => T;
}

export interface AvailabilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvailabilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvailabilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvailabilityPreviousValuesSubscription>() => T;
}

export interface AvailabilityPreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  end: DateTimeOutput;
}

export interface AvailabilityPreviousValuesPromise
  extends Promise<AvailabilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface AvailabilityPreviousValuesSubscription
  extends Promise<AsyncIterator<AvailabilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface BookingPreviousValues {
  id: ID_Output;
  timeSlot?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  timeSlot: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  timeSlot: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BusinessHourSubscriptionPayload {
  mutation: MutationType;
  node: BusinessHour;
  updatedFields: String[];
  previousValues: BusinessHourPreviousValues;
}

export interface BusinessHourSubscriptionPayloadPromise
  extends Promise<BusinessHourSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BusinessHourPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BusinessHourPreviousValuesPromise>() => T;
}

export interface BusinessHourSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BusinessHourSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BusinessHourSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BusinessHourPreviousValuesSubscription>() => T;
}

export interface BusinessHourPreviousValues {
  id: ID_Output;
  start?: String;
  end?: String;
}

export interface BusinessHourPreviousValuesPromise
  extends Promise<BusinessHourPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface BusinessHourPreviousValuesSubscription
  extends Promise<AsyncIterator<BusinessHourPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<String>>;
  end: () => Promise<AsyncIterator<String>>;
}

export interface ChargeSubscriptionPayload {
  mutation: MutationType;
  node: Charge;
  updatedFields: String[];
  previousValues: ChargePreviousValues;
}

export interface ChargeSubscriptionPayloadPromise
  extends Promise<ChargeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChargePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChargePreviousValuesPromise>() => T;
}

export interface ChargeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChargeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChargeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChargePreviousValuesSubscription>() => T;
}

export interface ChargePreviousValues {
  _id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: String;
  stripe_user_id: String;
  amount: Float;
  amount_refunded: Float;
  application_fee_amount?: Float;
  description?: String;
  receipt_url: String;
  refunded: Boolean;
  currency: String;
}

export interface ChargePreviousValuesPromise
  extends Promise<ChargePreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<String>;
  stripe_user_id: () => Promise<String>;
  amount: () => Promise<Float>;
  amount_refunded: () => Promise<Float>;
  application_fee_amount: () => Promise<Float>;
  description: () => Promise<String>;
  receipt_url: () => Promise<String>;
  refunded: () => Promise<Boolean>;
  currency: () => Promise<String>;
}

export interface ChargePreviousValuesSubscription
  extends Promise<AsyncIterator<ChargePreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<String>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Float>>;
  amount_refunded: () => Promise<AsyncIterator<Float>>;
  application_fee_amount: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  receipt_url: () => Promise<AsyncIterator<String>>;
  refunded: () => Promise<AsyncIterator<Boolean>>;
  currency: () => Promise<AsyncIterator<String>>;
}

export interface ContentSubscriptionPayload {
  mutation: MutationType;
  node: Content;
  updatedFields: String[];
  previousValues: ContentPreviousValues;
}

export interface ContentSubscriptionPayloadPromise
  extends Promise<ContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentPreviousValuesPromise>() => T;
}

export interface ContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentPreviousValuesSubscription>() => T;
}

export interface ContentPreviousValues {
  id: ID_Output;
  type?: String;
  message?: String;
}

export interface ContentPreviousValuesPromise
  extends Promise<ContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  message: () => Promise<String>;
}

export interface ContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  role: Role;
  email: String;
  emailToken?: String;
  emailTokenExpiry?: Float;
  inviteToken?: String;
  inviteTokenExpiry?: Float;
  resetToken?: String;
  resetTokenExpiry?: Float;
  verified: Boolean;
  name: String;
  password?: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  role: () => Promise<Role>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  name: () => Promise<String>;
  password: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<Role>>;
  email: () => Promise<AsyncIterator<String>>;
  emailToken: () => Promise<AsyncIterator<String>>;
  emailTokenExpiry: () => Promise<AsyncIterator<Float>>;
  inviteToken: () => Promise<AsyncIterator<String>>;
  inviteTokenExpiry: () => Promise<AsyncIterator<Float>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  url: String;
  width: Int;
  height: Int;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
}

export interface LastLoginSubscriptionPayload {
  mutation: MutationType;
  node: LastLogin;
  updatedFields: String[];
  previousValues: LastLoginPreviousValues;
}

export interface LastLoginSubscriptionPayloadPromise
  extends Promise<LastLoginSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LastLoginPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LastLoginPreviousValuesPromise>() => T;
}

export interface LastLoginSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LastLoginSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LastLoginSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LastLoginPreviousValuesSubscription>() => T;
}

export interface LastLoginPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  action: String;
}

export interface LastLoginPreviousValuesPromise
  extends Promise<LastLoginPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
}

export interface LastLoginPreviousValuesSubscription
  extends Promise<AsyncIterator<LastLoginPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  location: String;
  link?: String;
  recurring?: Boolean;
  maxSeats: Int;
  singleEvent?: Boolean;
  duration: Int;
  cost?: Int;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  link: () => Promise<String>;
  recurring: () => Promise<Boolean>;
  maxSeats: () => Promise<Int>;
  singleEvent: () => Promise<Boolean>;
  duration: () => Promise<Int>;
  cost: () => Promise<Int>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  recurring: () => Promise<AsyncIterator<Boolean>>;
  maxSeats: () => Promise<AsyncIterator<Int>>;
  singleEvent: () => Promise<AsyncIterator<Boolean>>;
  duration: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface SessionTypeSubscriptionPayload {
  mutation: MutationType;
  node: SessionType;
  updatedFields: String[];
  previousValues: SessionTypePreviousValues;
}

export interface SessionTypeSubscriptionPayloadPromise
  extends Promise<SessionTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionTypePreviousValuesPromise>() => T;
}

export interface SessionTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionTypePreviousValuesSubscription>() => T;
}

export interface SessionTypePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  duration: Int;
  maxSeats: Int;
  cost: Int;
}

export interface SessionTypePreviousValuesPromise
  extends Promise<SessionTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  maxSeats: () => Promise<Int>;
  cost: () => Promise<Int>;
}

export interface SessionTypePreviousValuesSubscription
  extends Promise<AsyncIterator<SessionTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  maxSeats: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Int>>;
}

export interface StripeAccountSubscriptionPayload {
  mutation: MutationType;
  node: StripeAccount;
  updatedFields: String[];
  previousValues: StripeAccountPreviousValues;
}

export interface StripeAccountSubscriptionPayloadPromise
  extends Promise<StripeAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StripeAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StripeAccountPreviousValuesPromise>() => T;
}

export interface StripeAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StripeAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StripeAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StripeAccountPreviousValuesSubscription>() => T;
}

export interface StripeAccountPreviousValues {
  id: ID_Output;
  stripe_user_id: String;
  access_token: String;
  scope: String;
  livemode: Boolean;
  token_type: String;
  refresh_token: String;
  stripe_publishable_key: String;
}

export interface StripeAccountPreviousValuesPromise
  extends Promise<StripeAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stripe_user_id: () => Promise<String>;
  access_token: () => Promise<String>;
  scope: () => Promise<String>;
  livemode: () => Promise<Boolean>;
  token_type: () => Promise<String>;
  refresh_token: () => Promise<String>;
  stripe_publishable_key: () => Promise<String>;
}

export interface StripeAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<StripeAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stripe_user_id: () => Promise<AsyncIterator<String>>;
  access_token: () => Promise<AsyncIterator<String>>;
  scope: () => Promise<AsyncIterator<String>>;
  livemode: () => Promise<AsyncIterator<Boolean>>;
  token_type: () => Promise<AsyncIterator<String>>;
  refresh_token: () => Promise<AsyncIterator<String>>;
  stripe_publishable_key: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  emailToken?: String;
  emailTokenExpiry?: Float;
  inviteToken?: String;
  inviteTokenExpiry?: Float;
  resetToken?: String;
  resetTokenExpiry?: Float;
  verified: Boolean;
  role: Role;
  name: String;
  username?: String;
  password?: String;
  timezone?: String;
  backgroundColor?: String;
  biography?: String;
  facebook?: String;
  twitter?: String;
  website?: String;
  mobile?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  emailToken: () => Promise<String>;
  emailTokenExpiry: () => Promise<Float>;
  inviteToken: () => Promise<String>;
  inviteTokenExpiry: () => Promise<Float>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  verified: () => Promise<Boolean>;
  role: () => Promise<Role>;
  name: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  timezone: () => Promise<String>;
  backgroundColor: () => Promise<String>;
  biography: () => Promise<String>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  website: () => Promise<String>;
  mobile: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  emailToken: () => Promise<AsyncIterator<String>>;
  emailTokenExpiry: () => Promise<AsyncIterator<Float>>;
  inviteToken: () => Promise<AsyncIterator<String>>;
  inviteTokenExpiry: () => Promise<AsyncIterator<Float>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<Role>>;
  name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  timezone: () => Promise<AsyncIterator<String>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  biography: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Image",
    embedded: false
  },
  {
    name: "StripeAccount",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "LastLogin",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Activity",
    embedded: false
  },
  {
    name: "Content",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "Availability",
    embedded: false
  },
  {
    name: "BusinessHour",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "SessionType",
    embedded: false
  },
  {
    name: "Charge",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
